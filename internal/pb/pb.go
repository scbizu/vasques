package pb

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

const (
	Annotion           = "// Auto generated by vasques\n"
	ProtoVersionHeader = `syntax = "proto3";`
)

var (
	packageName string
)

type Proto3 struct {
	mt   Meta
	msgs []Message
}

func NewPB3(p string) *Proto3 {
	return &Proto3{
		mt: Meta{
			packageName: p,
		},
	}
}

// AddMessage adds a flatten fields message
func (p3 *Proto3) AddMessage(name string, fs map[string]Field) {
	m := &Message{
		t:    TypeMessage,
		name: name,
	}
	var wire uint64
	for _, f := range fs {
		wire += 1
		m.AddField(f.types, f.varName, wire)
	}
	p3.msgs = append(p3.msgs, *m)
}

// AddEnum do we really need Enum type ?
func (p3 *Proto3) AddEnum(name string, fs map[string]Field) {}

type Meta struct {
	packageName string
}

type Message struct {
	t    MessageType
	name string
	fs   []Field
}

func (m *Message) AddField(ks []Keyword, varname string, wire uint64) {
	m.fs = append(m.fs, Field{
		types:   ks,
		varName: varname,
		wire:    wire,
	})
}

func (m Message) w() (string, error) {
	var buffer bytes.Buffer
	if _, err := buffer.WriteString(fmt.Sprintf("%s%s {\n", m.t.print(), m.name)); err != nil {
		return "", fmt.Errorf("message writer: %w", err)
	}
	for _, f := range m.fs {
		fs, err := f.format()
		if err != nil {
			return "", fmt.Errorf("message writer: %w", err)
		}
		if _, err := buffer.WriteString(fs); err != nil {
			return "", fmt.Errorf("message writer: %w", err)
		}
	}
	if _, err := buffer.WriteString("}\n"); err != nil {
		return "", fmt.Errorf("message writer: %w", err)
	}
	return buffer.String(), nil
}

func (m Meta) w() string {
	p := fmt.Sprintf("package %s;\n", m.packageName)
	return fmt.Sprintf("%s\n\n%s\n", ProtoVersionHeader, p)
}

func (m Meta) isPackageSet() bool {
	return m.packageName != ""
}

type Field struct {
	types   []Keyword
	varName string
	// wire is the auto incr index
	wire uint64
}

func NewField(t Keyword, isRepeat bool, varName string) Field {
	if isRepeat {
		return Field{
			types:   []Keyword{KeywordRepeated, t},
			varName: varName,
		}
	}
	return Field{
		types:   []Keyword{t},
		varName: varName,
	}
}

// format formats the f into types varName = wire;
// e.g: string foo = 1;
//  or: repeated string bar = 2;
func (f Field) format() (string, error) {
	if len(f.types) == 0 {
		return "", errors.New("Field format: bad wiretypes: must have one or more type")
	}

	wt := f.types[0]
	for _, t := range f.types[1:] {
		wt = wt.join(t)
	}
	return fmt.Sprintf("    %s%s = %d; \n", wt.print(), f.varName, f.wire), nil
}

func (p Proto3) write() (bytes.Buffer, error) {
	var buffer bytes.Buffer

	if p.mt.isPackageSet() {
		if _, err := buffer.WriteString(p.mt.w()); err != nil {
			return buffer, fmt.Errorf("pb writer: %w", err)
		}
	}

	for _, msg := range p.msgs {
		m, err := msg.w()
		if err != nil {
			return buffer, fmt.Errorf("pb writer: %w", err)
		}
		if _, err := buffer.WriteString(m); err != nil {
			return buffer, fmt.Errorf("pb writer: %w", err)
		}
	}

	return buffer, nil
}

func (p *Proto3) Generate(path string) error {
	b, err := p.write()
	if err != nil {
		return err
	}
	if path == "" {
		b.WriteTo(os.Stdout)
		return nil
	}
	pt, err := filepath.Abs(path)
	if err != nil {
		return fmt.Errorf("generate: %w", err)
	}
	return ioutil.WriteFile(pt, b.Bytes(), 0666)
}
